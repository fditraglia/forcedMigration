#' @param b Parameter for second principal component.
#' @param epicenter_1 First epicenter for violence origin (municipality code), allowing us to create models of outward spread from different origin pairs.
#' @param epicenter_2 Second epicenter for violence origin (municipality code).
#'
#' @return Dataframe containing distance, ring and municipality code.
#' Dataframe containing Municipality code, Year, Share, Ring, and Standard Deviation.
#'
#'\itemize{
#'    \item \code{total_dist} Distance between given pair of adjacent municipalities under metric.
#'  }
generate_distances <- function(metric,a,b,epicenter_1,epicenter_2){
munigraph <- forcedMigration::munigraph
# Figure out which PCA version to use (roads or no roads)
cross_section_merged <- forcedMigration::cross_section_merged
# Figure out which PCA version to use (roads or no roads)
for_pca <- forcedMigration::pca
if(metric == 3){
for_pca <- forcedMigration::roads_pca
}
# Shift PCA's to positive range.
for_pca$PC1 <- for_pca$PC1-min(for_pca$PC1)
for_pca$PC2 <- for_pca$PC2-min(for_pca$PC2)
for_pca$PC1 <- for_pca$PC1 / (max(for_pca$PC1))
for_pca$PC2 <- for_pca$PC2 / (max(for_pca$PC2))
for(i in 1:1120){
for(j in 1:1120){
# Initially, set total_dist (distance between municipalities i and j) to an effectively infinite number.
total_dist<-1000000
# Check that the municipalities are adjacent.
if(igraph::are.connected(munigraph,i,j)){
# Calculate crow-flies-distance.
d1 <- forcedMigration::calcdist(forcedMigration::AttributeTableFinal$latnum[i],forcedMigration::AttributeTableFinal$lonnum[i],forcedMigration::AttributeTableFinal$latnum[j],forcedMigration::AttributeTableFinal$lonnum[j])
# If we have no geographic covariates for at least one municipality in the pair (and therefore did not calculate a PCA distance for this pair), set total_dist to 1. (This is the "pure graph hops" case).
total_dist <- 1
# If using the crow-flies distance metric (or hiking, for cases where we lack elevation covariate), then set total_dist to d1.
if(metric == 1 | metric == 4){
total_dist <- d1
}
# For distinct municipalities for which we have all covariates, calculate the distance. (For municipalities lacking geographic covariates, we default to crow distance).
if(metric>1 & i!= j & i<nrow(forcedMigration::cross_section_merged) & j<nrow(forcedMigration::cross_section_merged)){
# Retrieve principal components 1 and 2 for municipalities i and j from PCA dataframe.
pcode_i <- forcedMigration::AttributeTableFinal$ADM2_PCODE[i]
pcode_j <- forcedMigration::AttributeTableFinal$ADM2_PCODE[j]
row <- for_pca[for_pca$muni_i == pcode_i & for_pca$muni_j == pcode_j,]$index
PCA_1 <- for_pca$PC1[row]
PCA_2 <- for_pca$PC2[row]
# Calculate total distance using our distance formula and save for summary statistics.
total_dist <- exp((a*PCA_1+b*PCA_2))
#summary_db[row] <- total_dist
# If we are using the hiking metric (and both municipalities are among the 1,076 for which we have geographic covariates), calculate and update distance. Where we don't have covariates, the default is d1.
if(metric==4 & i<nrow(forcedMigration::cross_section_merged) & j<nrow(forcedMigration::cross_section_merged) ){
elev_difference <- max((forcedMigration::cross_section_merged$alt_mean[i]-forcedMigration::cross_section_merged$alt_mean[j]),0)
total_dist <- d1 + 0.6 * elev_difference
#summary_db[row] <- total_dist
}
}
# Update and set edge weight.
#print(total_dist)
edge <- igraph::get.edge.ids(munigraph,c(i,j))
munigraph <- igraph::set_edge_attr(munigraph,"weight",edge,total_dist)
}
}
}
vertex_ids = vector(length = 1120)
for(i in 1:1120){
vertex_ids[i]<- forcedMigration::AttributeTableFinal$ADM2_PCODE[i]
}
# Calculate Dijkstra distances
delta_1 = igraph::distances(munigraph,v = which(vertex_ids == epicenter_1),to = igraph::V(munigraph),algorithm = "dijkstra")
delta_2 = igraph::distances(munigraph,v = which(vertex_ids == epicenter_2),to = igraph::V(munigraph),algorithm = "dijkstra")
deltas <- data.frame(matrix(c(delta_1,delta_2),ncol = 2))
colnames(deltas) <- c("delta_1","delta_2");
deltas <- dplyr::mutate(deltas, delta_min = as.numeric(purrr::map2(delta_1,delta_2,min)))
# Merge our distances (from specified epicenter) into dataframe containing map polygons.
distances <- as.numeric(deltas[,3])
# Dataset for merging delta and ring_num into other datasets by ADM2_PCODE.
merge_deltas <- data.frame(delta = distances,ADM2_PCODE = vertex_ids)
# Calculate ring as 10 * decile in distance distribution plus 1.
merge_deltas <- dplyr::mutate(merge_deltas, ring_num = as.integer(10*ecdf(merge_deltas$delta)(delta))+1)
# For the single largest delta in the dataset, decile is 10 and so ring is 11.
# Set ring_num to 10 for this case.
merge_deltas <- dplyr::mutate(merge_deltas, ring_num = ifelse(ring_num == 11,10,ring_num))
return(merge_deltas)
}
generate_distances(0,1,1,"CO05002","CO05002")
forcedMigration::generate_distances(0,1,1,"CO05002","CO05002")
forcedMigration::heatmap(0,1,1,"CO05002","CO05002")
# Read in shapefile.
muni_pol <- st_read("data-raw/col muni polygons/col_admbnda_adm2_mgn_20200416.shp")
